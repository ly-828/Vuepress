(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{401:function(t,a,s){"use strict";s.r(a);var e=s(54),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"事件对象event"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件对象event"}},[t._v("#")]),t._v(" 事件对象event")]),t._v(" "),s("h2",{attrs:{id:"event对象的基本属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event对象的基本属性"}},[t._v("#")]),t._v(" event对象的基本属性")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("  var box = document.querySelector('.box')\n  console.log(box)\n  box.onclick = function fn1(e){\n    //window.event.X轴坐标点信息 根据页面来显示的\n    var e=e||window.event\n    console.log(e.x)\n}\n")])])]),s("p",[t._v("此处的window.event自动的获得对该事件的所有信息，这样的写法具有兼容性。。适合多种版本的浏览器。\n其中的描述位置的主要有：")]),t._v(" "),s("ul",[s("li",[t._v("clienX依据浏览器边框而变化，会随着滑动而改变")]),t._v(" "),s("li",[t._v("offsetX点击的元素的边框开始计算，有边框可能有负值")]),t._v(" "),s("li",[t._v("pageX相对与整个页面的值，不会出现任何的变化。")])]),t._v(" "),s("h2",{attrs:{id:"事件监听"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[t._v("#")]),t._v(" 事件监听")]),t._v(" "),s("p",[t._v("addEventListener正序的监听 事件类型为click\nattachEvent倒序的监听** 事件类型为onclick方法")]),t._v(" "),s("h2",{attrs:{id:"事件冒泡与事件捕获"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件冒泡与事件捕获"}},[t._v("#")]),t._v(" 事件冒泡与事件捕获")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("IE中被称为事件冒泡，即自底向上获得事件的顺序，一直冒泡到document对象甚至是windows对象。")])]),t._v(" "),s("li",[s("p",[t._v("事件捕获是指从最外层的对象出发一直到最内层的对象")])])]),t._v(" "),s("h2",{attrs:{id:"事件代理-事件委托"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件代理-事件委托"}},[t._v("#")]),t._v(" 事件代理，事件委托")]),t._v(" "),s("p",[t._v("由冒泡机制延申出的，可以对内存进行优化，因为每个对象都是函数，会占用空间")]),t._v(" "),s("p",[t._v("利用事件冒泡的机制，把子元素的事件传递给父元素来做。利用target属性，哪个子事件触发，target就是这个子事件。\n兼容写法")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("obj1.addEventListener('click',function(e){\n        var e=e||window.event;\n        if(e.target.nodeName.toLowerCase()=='h5'){\n            alert(e.target.innerHTML);\n        }\n \n    },false);\n")])])]),s("h1",{attrs:{id:"this的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的使用"}},[t._v("#")]),t._v(" this的使用")]),t._v(" "),s("h2",{attrs:{id:"this只在函数被调用时才有实际的意义-优先级从低到高"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this只在函数被调用时才有实际的意义-优先级从低到高"}},[t._v("#")]),t._v(" this只在函数被调用时才有实际的意义，优先级从低到高")]),t._v(" "),s("h3",{attrs:{id:"默认绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#默认绑定"}},[t._v("#")]),t._v(" 默认绑定")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("    function sample(){\n    console.log(this.a)\n  }\n  var a=2\n  sample();\n")])])]),s("p",[t._v("此时结果为2，因为this默认绑定在全局变量上，this.a解析为了var a=2")]),t._v(" "),s("h3",{attrs:{id:"隐式绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隐式绑定"}},[t._v("#")]),t._v(" 隐式绑定")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("  function foo() { \n  console.log( this.a );\n  }\n  var a = 2;\n  var obj = { \n  a: 3,\n  foo: foo \n  };\n    obj.foo(); // ?\n")])])]),s("p",[t._v("此时的结果为3，因为obj对象中的foo属性是一个构造类对象，执行foo函数，执行foo函数时，this绑定的值应该是obj中的a=3（体现了优先级高于默认的全局this）")]),t._v(" "),s("blockquote",[s("p",[t._v("原则上this绑定在最近的函数上")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("函数别名")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("function foo() { \nconsole.log( this.a );\n}\n\nvar a = 2;\n\nvar obj = { \n  a: 3,\n  foo: foo \n};\n\nvar bar = obj.foo;\nbar();  \n")])])]),s("p",[t._v("结果等于2（涉及到属性）这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。")]),t._v(" "),s("p",[t._v("那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定全局属性a。")])]),t._v(" "),s("li",[s("p",[t._v("回调函数，与上面的情况一样")])])]),t._v(" "),s("h3",{attrs:{id:"显示绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#显示绑定"}},[t._v("#")]),t._v(" 显示绑定")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("  function foo(){\n    console.log(this.a)\n  }\n  var obj1={\n    a:3\n  };\n  var bar=function(){\n    foo.call(obj1);\n  }\n  bar();\n")])])]),s("p",[t._v("结果为3，因为call的绑定作用,将***foo绑定到obj1这个函数里面去了")]),t._v(" "),s("h3",{attrs:{id:"new-绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-绑定"}},[t._v("#")]),t._v(" new 绑定")]),t._v(" "),s("p",[t._v("通过new创建的函数，this会自动指向这个函数")]),t._v(" "),s("h1",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),s("p",[t._v("函数实际上是对象，每个函数都是Function的实例，而Function也有属性和方法。")]),t._v(" "),s("h2",{attrs:{id:"闭包与块级作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包与块级作用域"}},[t._v("#")]),t._v(" 闭包与块级作用域")]),t._v(" "),s("p",[t._v("引用了另一个函数作用域里变量的函数\n「函数」和「函数内部能访问到的变量」的总和，就是一个闭包\n通过闭包来实现在函数作用域内部改变而不影响外部")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("(function(){})()\n")])])]),s("p",[t._v("var是没有块级作用域的==>{}，只有函数有作用域")]),t._v(" "),s("h2",{attrs:{id:"const与let"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const与let"}},[t._v("#")]),t._v(" const与let")]),t._v(" "),s("ul",[s("li",[t._v("const一般用来绑定对象，因为const是不能修改的，但是绑定的对象的属性可以修改")]),t._v(" "),s("li",[t._v("let用来取代var，因为let有块级作用域，const没有")])]),t._v(" "),s("h2",{attrs:{id:"构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数")]),t._v(" "),s("h1",{attrs:{id:"prototype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prototype"}},[t._v("#")]),t._v(" prototype")]),t._v(" "),s("h1",{attrs:{id:"正则表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[t._v("#")]),t._v(" 正则表达式")]),t._v(" "),s("p",[t._v("\\d 表示一个数字，等价于[0-9]\n\\w 匹配字母、数字或者下划线,等价于 [A-Za-z0-9_]\n+匹配前面一个表达式 1 次或者多次\n*匹配前一个表达式 0 次或多次\n/g全局匹配")]),t._v(" "),s("h1",{attrs:{id:"跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[t._v("#")]),t._v(" 跨域")]),t._v(" "),s("p",[t._v("跨域是指协议、域名、端口三者相同时，才能访问到数据，否则不能访问。\njavascript中实现跨域的方式总结")]),t._v(" "),s("ul",[s("li",[t._v("第一种方式：jsonp请求；jsonp的原理是利《script>标签的跨域特性，可以不受限制地从其他域中加载资源。")])]),t._v(" "),s("p",[t._v("凡是带有src标签的都具有跨域的能力，可以调用js文件。\n将json作为js脚本的形式进行调用。")]),t._v(" "),s("ul",[s("li",[t._v("第二种方式：document.domain；这种方式用在主域名相同子域名不同的跨域访问中")]),t._v(" "),s("li",[t._v("第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。")]),t._v(" "),s("li",[t._v("第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。")]),t._v(" "),s("li",[t._v("第五种方式：CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。")]),t._v(" "),s("li",[t._v("第六种方式：Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。")])]),t._v(" "),s("h1",{attrs:{id:"bom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bom"}},[t._v("#")]),t._v(" BOM")]),t._v(" "),s("p",[t._v("浏览器的内置对象管理模型，简称BOM(Browser Object Model)中的Histroy属性和方法。\nlength 返回浏览器历史列表中的URL数量。所以C中表述的长度信息是错误的。")]),t._v(" "),s("p",[t._v("back() 加载 history列表中的前一个URL。")]),t._v(" "),s("p",[t._v("forward() 加载  history  列表中的下一个URL。")]),t._v(" "),s("p",[t._v("go()  加载history列表中的某个具体页面。所以B的表述刷新当前页面是错误的。")]),t._v(" "),s("h1",{attrs:{id:"多种http的差别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多种http的差别"}},[t._v("#")]),t._v(" 多种http的差别")]),t._v(" "),s("h1",{attrs:{id:"cookie和session理解和差异"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie和session理解和差异"}},[t._v("#")]),t._v(" cookie和session理解和差异")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("cookie数据存放在客户的浏览器上，session数据放在服务器上。")])]),t._v(" "),s("li",[s("p",[t._v("cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。")])]),t._v(" "),s("li",[s("p",[t._v("session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n考虑到减轻服务器性能方面，应当使用COOKIE。")])]),t._v(" "),s("li",[s("p",[t._v("单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。")])])]),t._v(" "),s("h1",{attrs:{id:"防抖和节流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#防抖和节流"}},[t._v("#")]),t._v(" 防抖和节流")]),t._v(" "),s("p",[t._v("防抖和节流的区别")]),t._v(" "),s("ul",[s("li",[t._v("防抖是指，当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时")]),t._v(" "),s("li",[t._v("节流是指，持续触发事件时，保证一定时间段内只调用一次事件处理函数。\n代码如下；")])])])}),[],!1,null,null,null);a.default=n.exports}}]);