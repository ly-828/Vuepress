<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件对象event | 网站标题</title>
    <meta name="generator" content="VuePress 1.9.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.20b92855.css" as="style"><link rel="preload" href="/assets/js/app.2bf13046.js" as="script"><link rel="preload" href="/assets/js/2.d2965c34.js" as="script"><link rel="preload" href="/assets/js/15.7804a37b.js" as="script"><link rel="prefetch" href="/assets/js/10.4c0173d4.js"><link rel="prefetch" href="/assets/js/11.6d43fa2c.js"><link rel="prefetch" href="/assets/js/12.7323437c.js"><link rel="prefetch" href="/assets/js/13.a5fabeb6.js"><link rel="prefetch" href="/assets/js/14.d13aa1e4.js"><link rel="prefetch" href="/assets/js/16.64fbc108.js"><link rel="prefetch" href="/assets/js/17.fd1258a6.js"><link rel="prefetch" href="/assets/js/18.738c0819.js"><link rel="prefetch" href="/assets/js/3.3086e9e4.js"><link rel="prefetch" href="/assets/js/4.5a4f4779.js"><link rel="prefetch" href="/assets/js/5.40592602.js"><link rel="prefetch" href="/assets/js/6.209d3b22.js"><link rel="prefetch" href="/assets/js/7.ff89161b.js"><link rel="prefetch" href="/assets/js/8.5fab2969.js"><link rel="prefetch" href="/assets/js/9.d0c82ba8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.20b92855.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">网站标题</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/accumulate/" aria-current="page" class="sidebar-link">测试界面</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>第一部分</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件对象event"><a href="#事件对象event" class="header-anchor">#</a> 事件对象event</h1> <h2 id="event对象的基本属性"><a href="#event对象的基本属性" class="header-anchor">#</a> event对象的基本属性</h2> <div class="language- extra-class"><pre><code>  var box = document.querySelector('.box')
  console.log(box)
  box.onclick = function fn1(e){
    //window.event.X轴坐标点信息 根据页面来显示的
    var e=e||window.event
    console.log(e.x)
}
</code></pre></div><p>此处的window.event自动的获得对该事件的所有信息，这样的写法具有兼容性。。适合多种版本的浏览器。
其中的描述位置的主要有：</p> <ul><li>clienX依据浏览器边框而变化，会随着滑动而改变</li> <li>offsetX点击的元素的边框开始计算，有边框可能有负值</li> <li>pageX相对与整个页面的值，不会出现任何的变化。</li></ul> <h2 id="事件监听"><a href="#事件监听" class="header-anchor">#</a> 事件监听</h2> <p>addEventListener正序的监听 事件类型为click
attachEvent倒序的监听** 事件类型为onclick方法</p> <h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="header-anchor">#</a> 事件冒泡与事件捕获</h2> <ul><li><p>IE中被称为事件冒泡，即自底向上获得事件的顺序，一直冒泡到document对象甚至是windows对象。</p></li> <li><p>事件捕获是指从最外层的对象出发一直到最内层的对象</p></li></ul> <h2 id="事件代理-事件委托"><a href="#事件代理-事件委托" class="header-anchor">#</a> 事件代理，事件委托</h2> <p>由冒泡机制延申出的，可以对内存进行优化，因为每个对象都是函数，会占用空间</p> <p>利用事件冒泡的机制，把子元素的事件传递给父元素来做。利用target属性，哪个子事件触发，target就是这个子事件。
兼容写法</p> <div class="language- extra-class"><pre><code>obj1.addEventListener('click',function(e){
        var e=e||window.event;
        if(e.target.nodeName.toLowerCase()=='h5'){
            alert(e.target.innerHTML);
        }
 
    },false);
</code></pre></div><h1 id="this的使用"><a href="#this的使用" class="header-anchor">#</a> this的使用</h1> <h2 id="this只在函数被调用时才有实际的意义-优先级从低到高"><a href="#this只在函数被调用时才有实际的意义-优先级从低到高" class="header-anchor">#</a> this只在函数被调用时才有实际的意义，优先级从低到高</h2> <h3 id="默认绑定"><a href="#默认绑定" class="header-anchor">#</a> 默认绑定</h3> <div class="language- extra-class"><pre><code>    function sample(){
    console.log(this.a)
  }
  var a=2
  sample();
</code></pre></div><p>此时结果为2，因为this默认绑定在全局变量上，this.a解析为了var a=2</p> <h3 id="隐式绑定"><a href="#隐式绑定" class="header-anchor">#</a> 隐式绑定</h3> <div class="language- extra-class"><pre><code>  function foo() { 
  console.log( this.a );
  }
  var a = 2;
  var obj = { 
  a: 3,
  foo: foo 
  };
    obj.foo(); // ?
</code></pre></div><p>此时的结果为3，因为obj对象中的foo属性是一个构造类对象，执行foo函数，执行foo函数时，this绑定的值应该是obj中的a=3（体现了优先级高于默认的全局this）</p> <blockquote><p>原则上this绑定在最近的函数上</p></blockquote> <ul><li><p>函数别名</p> <div class="language- extra-class"><pre><code>function foo() { 
console.log( this.a );
}

var a = 2;

var obj = { 
  a: 3,
  foo: foo 
};

var bar = obj.foo;
bar();  
</code></pre></div><p>结果等于2（涉及到属性）这里有个概念要理解清楚，obj.foo 是引用属性，赋值给bar的实际上就是foo函数（即：bar指向foo本身）。</p> <p>那么，实际的调用关系是：通过bar找到foo函数，进行调用。整个调用过程并没有obj的参数，所以是默认绑定全局属性a。</p></li> <li><p>回调函数，与上面的情况一样</p></li></ul> <h3 id="显示绑定"><a href="#显示绑定" class="header-anchor">#</a> 显示绑定</h3> <div class="language- extra-class"><pre><code>  function foo(){
    console.log(this.a)
  }
  var obj1={
    a:3
  };
  var bar=function(){
    foo.call(obj1);
  }
  bar();
</code></pre></div><p>结果为3，因为call的绑定作用,将***foo绑定到obj1这个函数里面去了</p> <h3 id="new-绑定"><a href="#new-绑定" class="header-anchor">#</a> new 绑定</h3> <p>通过new创建的函数，this会自动指向这个函数</p> <h1 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h1> <p>函数实际上是对象，每个函数都是Function的实例，而Function也有属性和方法。</p> <h2 id="闭包与块级作用域"><a href="#闭包与块级作用域" class="header-anchor">#</a> 闭包与块级作用域</h2> <p>引用了另一个函数作用域里变量的函数
「函数」和「函数内部能访问到的变量」的总和，就是一个闭包
通过闭包来实现在函数作用域内部改变而不影响外部</p> <div class="language- extra-class"><pre><code>(function(){})()
</code></pre></div><p>var是没有块级作用域的==&gt;{}，只有函数有作用域</p> <h2 id="const与let"><a href="#const与let" class="header-anchor">#</a> const与let</h2> <ul><li>const一般用来绑定对象，因为const是不能修改的，但是绑定的对象的属性可以修改</li> <li>let用来取代var，因为let有块级作用域，const没有</li></ul> <h2 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h2> <h1 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h1> <h1 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h1> <p>\d 表示一个数字，等价于[0-9]
\w 匹配字母、数字或者下划线,等价于 [A-Za-z0-9_]
+匹配前面一个表达式 1 次或者多次
*匹配前一个表达式 0 次或多次
/g全局匹配</p> <h1 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h1> <p>跨域是指协议、域名、端口三者相同时，才能访问到数据，否则不能访问。
javascript中实现跨域的方式总结</p> <ul><li>第一种方式：jsonp请求；jsonp的原理是利《script&gt;标签的跨域特性，可以不受限制地从其他域中加载资源。</li></ul> <p>凡是带有src标签的都具有跨域的能力，可以调用js文件。
将json作为js脚本的形式进行调用。</p> <ul><li>第二种方式：document.domain；这种方式用在主域名相同子域名不同的跨域访问中</li> <li>第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</li> <li>第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。</li> <li>第五种方式：CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。</li> <li>第六种方式：Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</li></ul> <h1 id="bom"><a href="#bom" class="header-anchor">#</a> BOM</h1> <p>浏览器的内置对象管理模型，简称BOM(Browser Object Model)中的Histroy属性和方法。
length 返回浏览器历史列表中的URL数量。所以C中表述的长度信息是错误的。</p> <p>back() 加载 history列表中的前一个URL。</p> <p>forward() 加载  history  列表中的下一个URL。</p> <p>go()  加载history列表中的某个具体页面。所以B的表述刷新当前页面是错误的。</p> <h1 id="多种http的差别"><a href="#多种http的差别" class="header-anchor">#</a> 多种http的差别</h1> <h1 id="cookie和session理解和差异"><a href="#cookie和session理解和差异" class="header-anchor">#</a> cookie和session理解和差异</h1> <ol><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p></li> <li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。</p></li> <li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用COOKIE。</p></li> <li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p></li></ol> <h1 id="防抖和节流"><a href="#防抖和节流" class="header-anchor">#</a> 防抖和节流</h1> <p>防抖和节流的区别</p> <ul><li>防抖是指，当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时</li> <li>节流是指，持续触发事件时，保证一定时间段内只调用一次事件处理函数。
代码如下；</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2bf13046.js" defer></script><script src="/assets/js/2.d2965c34.js" defer></script><script src="/assets/js/15.7804a37b.js" defer></script>
  </body>
</html>
